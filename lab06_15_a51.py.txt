op2=>operation: from base import alphabet, input_for_cipher_short, input_for_cipher_long, output_from_decrypted
op4=>operation: import re
op6=>operation: import copy
op8=>operation: reg_x_length = 19
op10=>operation: reg_y_length = 22
op12=>operation: reg_z_length = 23
op14=>operation: key_one = ''
op16=>operation: reg_x = []
op18=>operation: reg_y = []
op20=>operation: reg_z = []
st23=>start: start loading_registers
io25=>inputoutput: input: key
op28=>operation: i = 0
cond31=>condition: while (i < reg_x_length)
sub40=>subroutine: reg_x.insert(i, int(key[i]))
op42=>operation: i = (i + 1)
op46=>operation: j = 0
op48=>operation: p = reg_x_length
cond51=>condition: while (j < reg_y_length)
sub62=>subroutine: reg_y.insert(j, int(key[p]))
op64=>operation: p = (p + 1)
op66=>operation: j = (j + 1)
op70=>operation: k = (reg_y_length + reg_x_length)
op72=>operation: r = 0
cond75=>condition: while (r < reg_z_length)
sub86=>subroutine: reg_z.insert(r, int(key[k]))
op88=>operation: k = (k + 1)
op90=>operation: r = (r + 1)
e94=>end: end loading_registers
st98=>start: start set_key
io100=>inputoutput: input: key
cond104=>condition: if ((len(key) == 64) and re.match('^([01])+', key))
op108=>operation: key_one = key
sub110=>subroutine: loading_registers(key)
io115=>inputoutput: output:  True
e113=>end: end function return
io124=>inputoutput: output:  False
e122=>end: end function return

op2->op4
op4->op6
op6->op8
op8->op10
op10->op12
op12->op14
op14->op16
op16->op18
op18->op20
op20->st23
st23->io25
io25->op28
op28->cond31
cond31(yes)->sub40
sub40->op42
op42(left)->cond31
cond31(no)->op46
op46->op48
op48->cond51
cond51(yes)->sub62
sub62->op64
op64->op66
op66(left)->cond51
cond51(no)->op70
op70->op72
op72->cond75
cond75(yes)->sub86
sub86->op88
op88->op90
op90(left)->cond75
cond75(no)->e94
e94->st98
st98->io100
io100->cond104
cond104(yes)->op108
op108->sub110
sub110->io115
io115->e113
cond104(no)->io124
io124->e122

